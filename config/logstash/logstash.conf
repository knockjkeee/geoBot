input {
  http {
    port => 5005
    host => "0.0.0.0"
   # codec => json {
   #   target => "event"
   # }
    add_field => {
      "type" => "http_json"
      "input_type" => "http"
      "environment" => "development"
    }
    user => "${HTTP_USER_LOGSTASH}"
    password => "${HTTP_PW_LOGSTASH}"

  }

  beats {
    port => 5044
    type => "beats"
  }

}

filter {
  # Удаляем чувствительные заголовки
  mutate {
    remove_field => ["headers", "host"]
  }

  # ВАЖНО: Если данные приходят с вложенной структурой data.service, data.message и т.д.
  # Поднимаем эти поля на верхний уровень
  if [data] {
    ruby {
      code => "
        data = event.get('data')
        if data.is_a?(Hash)
          data.each do |key, value|
            event.set(key, value)
          end
        end
      "
    }
  }

  # Обработка временных меток (проверяем оба варианта)
  if [timestamp] {
    date {
      match => ["timestamp", "ISO8601", "yyyy-MM-dd'T'HH:mm:ss.SSSSSS"]
      target => "@timestamp"
      timezone => "UTC"
    }
  } else if [@timestamp] {
    # Используем существующий @timestamp
  }

  # Устанавливаем индекс по умолчанию, если service не определен
  if ![service] {
    mutate {
      add_field => { "[@metadata][index]" => "unknown-service" }
      add_tag => ["no_service_field"]
    }
  }

  # Маршрутизация по сервисам
  if [service] == "logger-service" {
    mutate {
      add_field => { "[@metadata][index]" => "logger-service" }
      add_tag => ["logger"]
    }
  } else if [service] {
    # Для любых других сервисов используем имя сервиса как индекс
    mutate {
      add_field => { "[@metadata][index]" => "%{service}" }
      add_tag => ["custom_service"]
    }
  }

  # Обработка action из данных
  if [action] {
    mutate {
      add_field => { "action_type" => "%{action}" }
      add_tag => ["action_%{action}"]
    }
  }

  # Обработка уровня логирования
  if [level] {
    mutate {
      lowercase => ["level"]
    }

    if [level] == "error" {
      mutate {
        add_tag => ["error"]
      }
    } else if [level] == "warning" or [level] == "warn" {
      mutate {
        add_tag => ["warning"]
      }
    } else if [level] == "critical" or [level] == "fatal" {
      mutate {
        add_tag => ["critical"]
      }
    }
  }

    # Добавляем метаданные для лучшей организации
  mutate {
    add_field => {
      "[@metadata][pipeline]" => "main"
      "[@metadata][beat]" => "logstash"
    }
  }

  # Удаляем пустые поля
  #prune {
  #  whitelist_names => ["^@.*", "^service$", "^level$", "^message$", "^timestamp$", "^tags$", "^type$"]
  #}

}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "%{[@metadata][index]}-%{+YYYY.MM.dd}"
    user => "${ELASTIC_USER}"
    password => "${ELASTIC_PASSWORD}"

    # Управление шаблонами индексов
    manage_template => true
    template_name => "logstash"
    template_overwrite => false

    # Настройки производительности
    pool_max => 512
    pool_max_per_route => 100

    # Обработка ошибок
    action => "index"
    retry_on_conflict => 3
  }

  # Отдельный индекс для ошибок
  if "error" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      user => "${ELASTIC_USER}"
      password => "${ELASTIC_PASSWORD}"
      index => "errors-%{+YYYY.MM.dd}"
    }
  }

  # Отдельный индекс для критических ошибок
  if "critical" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      user => "${ELASTIC_USER}"
      password => "${ELASTIC_PASSWORD}"
      index => "critical-%{+YYYY.MM.dd}"
    }
  }

    # Опциональный вывод в stdout для дебага (закомментирован)
    stdout {
     codec => rubydebug {
       metadata => true
     }
    }

}
